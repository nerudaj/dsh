"use strict";

var version = '2.0.0';

'static'; var va = 1;
'static'; var vb = false;
/**
 *  \brief Cache for speeding up text-fit computations
 */
'static'; var vc = {}






// =============== //
// === METHODS === //
// =============== //
'static'; function fa() {
	vc = {};
}

/**
 *  @brief Get reference to DOM object by id
 */
'static'; function fb(id) {
	return document.getElementById(id);
}

'static'; function fc(id) {
	return document.getElementsByName(id);
}

/**
 *  @brief Display error message
 *  
 *  @param [in] module Origin module of message
 *  @param [in] func In which function message occured
 *  @param [in] message Message itself
 *  
 *  @details The message will be printed to console.error and
 *  also will be printed by alert. Alert printing can be supressed
 *  globally by setting va to 0.
 */
'static'; function fd(module, func, message) {
	var str = "ERROR: " + module + "::" + func + ": " + message;
	console.error(str);
	
	if(va > 0) alert(str);
}

/**
 *  @brief Get random number
 *  
 *  @param [in] min Minimum value(exclusive)
 *  @param [in] max Maximum value(exclusive)
 *  @return fe number
 */
'static'; function fe(min, max) {
	return Math.floor((Math.random() * max) + min);
}

/**
 *  @brief Assign default value to undefined argument
 *  
 *  @param [in] arg Argument to test
 *  @param [in] value Default value
 *  @return \p arg or \p value
 *  
 *  @details If \p arg is undefined then value is returned. Otherwise the \p arg is returned.
 */
'static'; function ff(arg, value) {
	return typeof arg !== "undefined" ? arg : value;
}

/**
 *  @brief How big the font should be to text fit the given boundaries
 *  
 *  @param [in] str Text that should fit
 *  @param [in] width Width of the bounding box
 *  @param [in] height Height of the bounding box
 *  @param [in] startSize From which fontSize the algorithm should start(Default: 100)
 *  @return Optimal font size
 *  
 *  @details This function does not take into account word breaking. Also, the algorithm looks for
 *  the first fontSize that fit, so if you're element is bigger than a text at fontSize 100, try
 *  tweaking the \p startSize to higher values like 500.
 *  
 *  For this to work, the html file must contain element with id 'HiddenResizer'. This element
 *  has to be span with visibility:hidden.
 */
'static'; function fg(str, width, height, startSize) {
	var fontSize = ff(startSize, 100);
	
	var resizer = fb("HiddenResizer");
	resizer.style.fontSize = fontSize + "px";
	
	resizer.innerHTML = str;
	var rw = resizer.offsetWidth;
	var rh = resizer.offsetHeight;
	
	while(rw > width * 0.8 || rh > height * 0.8) {
		fontSize -= 1;
		resizer.style.fontSize = fontSize + "px";
		rw = resizer.offsetWidth;
		rh = resizer.offsetHeight;
	}
	
	return fontSize;
}

// =============== //
// === aELEMENT === //
// =============== //
'static'; function fh() {
	this.dom = null; ///< DOM of the element
	this.width = 0; ///< Width of the element in pixels
	this.height = 0; ///< Height of the element in pixels
}

/**
 *  @brief Add sub element to element
 *  
 *  @param [in] x X coordinate, in %.
 *  @param [in] y Y coordinate, in %.
 *  @param [in] w Width of the element, in %.
 *  @param [in] h Height of the element, in %.
 *  @param [in] type Type of the element.(Default: div)
 *  @param [in] id ID of the DOM.(Default: none)
 *  @return Reference to new element
 *  
 *  @details Parent element defines the coordinate system for the subelement.
 *  All % values are numbers from 0 to 1. XY goes from topleft corner of the
 *  parent element. Example: To create an element that takes left half of the parent,
 *  use add(0, 0, 0.5, 1);
 */
fh.prototype.add = function(x, y, w, h, type, id) {
	type = ff(type, "div");
	id = ff(id, null);

	var result = new fh();

	var node = document.createElement(type);
	
	if(id != null) {
		node.setAttribute("id", id);
	}
	
	this.dom.appendChild(node);

	result.dom = node;
	result.width = this.width * w;
	result.height= this.height * h;

	result.dom.style.position = "absolute";
	result.dom.style.left = this.width * x + "px";
	result.dom.style.top = this.height * y + "px";
	result.dom.style.width = result.width + "px";
	result.dom.style.height = result.height + "px";
	
	if(type == 'input') {
		result.pd('focus', function() { vb = true; });
		result.pd('blur', function() { setTimeout(function() { vb = false; }, 500); });
	}

	return result;
}

/**
 *  @brief Set background color of an element
 *  
 *  @param [in] color Valid CSS string for color. You can use canonical names, hexa(#HHHHHH), hsl, rgb, ...
 */
'static'; fh.prototype.pa = function(color) {
	this.dom.style.background = color;
}

/**
 *  @brief Set text to the element
 *  
 *  @param [in] str Text
 *  @param [in] autofit Whether the text should autofit the element(Default: false)
 *  @param [in] startsize Starting fontSize for \ref fg.(Default: 100)
 *  
 *  @details If the text is not set to autofit, the fontSize is implicit and words can
 *  break.
 */
'static'; fh.prototype.pb = function(str, autofit, startSize) {
	autofit = ff(autofit, false);
	
	var fontSize = null;
	
	if(autofit) {
		startSize = ff(startSize, 100);
		fontSize = fg(str, this.width, this.height, startSize);
	}
	else if(startSize !== 'undefined') {
		fontSize = startSize;
	}
	
	var t = document.createTextNode(str);
	
	if(fontSize != null) {
		this.dom.style.fontSize = fontSize + "px";
	}
	
	this.dom.appendChild(t);
}

'static'; fh.prototype.pc = function(name) {
	this.dom.className += ' ' + name;
}

'static'; fh.prototype.pd = function(event, action) {
	this.dom.addEventListener(event, action);
}

// ============ //
// === VIEW === //
// ============ //
/**
 *  @brief Single page view of the application
 *  
 *  @details This object represents a single page of
 *  your application. Application can consist of many views.
 *  All views share the same canvas and when one is rendered,
 *  it deletes any data previously rendered to the canvas.
 *  
 *  When creating new view, placeholder \ref pe method is
 *  used. You are obligated to replace it with your own. Then
 *  you can access the drawing canvas with this.app.canvas
 *  and you can also access app's shared data with this.app.context.
 */
'static'; function fi() {
	this.app = null; ///< Reference to the app object
}

/**
 *  @brief Render this view
 *  
 *  @details This method is only a placeholder. Upon creating new
 *  view, you are obligated to set this.pe to your own callback.
 */
'static'; fi.prototype.pe = function() {
	fd("ClassView", "render", "This method is not implemented!");
}

/**
 *  @brief Bootstrap the view
 *  
 *  @param [in] canvas Reference to the \ref App object
 *  
 *  @details This method is called automatically by \ref App during \ref pg.
 */
'static'; fi.prototype.pf = function(app) {
	this.app = app;
}

// =========== //
// === APP === //
// =========== //
/**
 *  @brief Object representing app itself
 *  
 *  @details App consists of drawing canvas, shared context
 *  and a number of view between which you can freely toggle.
 */
'static'; function fj() {
	this.context = {}; ///< Shared application context. Any data that should be persistent has to be saved there
	this.canvas = new fh(); ///< Core drawing canvas
	this.views = {}; ///< Storage for views
	this.currentView = ""; ///< Index to current view
}

/**
 *  @brief Add new view to application
 *  
 *  @param [in] view \ref View object
 *  @param [in] name Name for the view(must be unique)
 *  @return TRUE on success, FALSE if view already exists
 *  
 *  @details View is bootstraped automatically if added
 *  successfully.
 */
'static'; fj.prototype.pg = function(view, name) {
	var views = this.views;
	
	if(views.hasOwnProperty(name)) {
		fd("ClassApp", "addView", "View with name " + name + " already exists!");
		return false;
	}
	
	views[name] = view;
	views[name].pf(this);
	
	return true;
}

/**
 *  @brief Change the rendered view
 *  
 *  @param [in] name Name of the view to change to
 *  
 *  @pre \ref pg with \p name was called
 */
'static'; fj.prototype.ph = function(name) {
	if(!this.views.hasOwnProperty(name)) {
		fd("ClassApp", "toggleView", "View called " + name + " does not exist!");
		return;
	}
	
	this.currentView = name;
	this.pe();
}

/**
 *  @brief Render app. Basically redraws currently selected view
 *  
 *  @details When app is redrawed it also recomputes viewport, so it will resize if needed
 */
'static'; fj.prototype.pe = function() {
	var canvas = this.canvas;
	
	// Clear everything rendered so far
	canvas.dom.innerHTML = "";
	
	// Resize canvas
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
	
	canvas.dom.style.position = "absolute";
	canvas.dom.style.width = canvas.width + "px";
	canvas.dom.style.height = canvas.height + "px";
	
	// Render current view
	this.views[this.currentView].pe();
}

/**
 *  @brief Bootstrap the app
 *  
 *  @param [in] id ID of the core canvas DOM element
 *  
 *  @details This method should be called as the first
 *  thing in your program. It registers automatic resize
 *  of the app as well as it binds to drawing canvas.
 */
'static'; fj.prototype.pf = function(id) {
	this.canvas.dom = fb(id);
	
	var that = this;
	window.addEventListener('resize', function() {
		if(vb) return;
		fa();
		that.pe();
	});
};'static'; function fk() {
	var canvas = this.app.canvas;
	
	fA(canvas, "Hints");
	
	var board = fB(canvas);
	board.pb('TODO: hints');
	
	var buttons = [
		new fx('Back', function() {
			app.ph('mainpage');
		})
	];
	fz(canvas, buttons, 'a');
};// Global variables
var app = new fj();

// Bootstrap app
function Main() {
	// Bootstrap app
	app.pf('Canvas');

	// Setup app context
	// app.context['key'] = value;

	// Setup views
	var views = [
		{ callback: fl, name: 0 },
		{ callback: fk, name: 1 }
	];
	
	// Add views to app
	for(var i = 0; i < views.length; i++) {
		var view = new fi();
		view.pe = views[i].callback;
		app.pg(view, views[i].name);
	}
	
	// Toggle default view
	app.ph(0);
};'static'; var vd = 100;
'static'; var ve = 25; // in ms
'static'; var vf = 1; // in s

/* PUBLIC FUNCTION DB START */
function Power(x, exp) {
	var result = 1;
	for(var i = 0; i < exp; i++) result = result * x;
	return result;
}

function Flip(x) {
	return 1-x;
}

function SmoothStart(x, level) {
	return Math.pow(x, level);
}

function SmoothStop(x, level) {
	return Flip(SmoothStart(Flip(x), level));
}

function Crossfade(a, b, x) {
	return a +(b - a) * x;
}
/* PUBLIC FUNCTION DB END */

'static'; function fl() {
	var canvas = this.app.canvas;
	
	var board = fB(canvas, false); // No header
	
	if(fn(board)) {
		fo(this.app, board);
	}
	else {
		fp(this.app, board);
	}
	
	var buttons = [
		new fx('Apply', function() {
			fu(app);
		}),
		new fx('Hints', function() {
			clearInterval(app.context.handle);
			app.ph('hints');
		})
	];
	fz(canvas, buttons, 'a');
	
	fm(this.app);
}

// -------- First level

'static'; function fm(app) {
	var context = app.context;
	if(context.handle != null) {
		clearInterval(context.handle);
		context.handle = null;
	}
}

'static'; function fn(canvas) {
	console.log(canvas.width > canvas.height);
	return canvas.width > canvas.height;
}

'static'; function fo(app, canvas) {
	// Precompute header size to cache
	if(vc['b'] == null) {
		vc['b'] = fg(
			'Function visualisation:',
			canvas.width * 0.5,
			canvas.height * 0.5 * 0.25,
			1000
		);
	}
	
	var inputbar = canvas.add(0, 0, 0.5, 0.5);
	fr(app, inputbar, 0.25);
	
	var displaybar = canvas.add(0.5, 0, 0.5, 0.5);
	fs(app, displaybar);
	
	var animbar = canvas.add(0, 0.5, 1, 0.5);
	ft(app, animbar);
}

'static'; function fp(app, canvas) {
	// Precompute header size to cache
	if(vc['b'] == null) {
		vc['b'] = fg(
			'Function visualisation:',
			canvas.width * 0.5,
			canvas.height * 0.1,
			1000
		);
	}
	
	var inputbar = canvas.add(0, 0, 1, 0.2);
	fr(app, inputbar, 0.5);
	
	var displaybar = canvas.add(0, 0.2, 1, 0.4);
	fs(app, displaybar);
	
	var animbar = canvas.add(0, 0.6, 1, 0.4);
	ft(app, animbar);
}

// --------- Second level
'static'; function fq(header, label) {
	header.pb(label, false, vc['b']);
	//header.pb(label, true);
}

'static'; function fr(app, canvas, headerHeight) {
	var header = canvas.add(0, 0, 1, headerHeight);
	fq(header, 'Input function:');
	
	var inputwrap = canvas.add(0, headerHeight, 1, 1 - headerHeight);
	
	var offsetX = 20 / inputwrap.width;
	var offsetY = 20 / inputwrap.height;
	var input = inputwrap.add(offsetX, offsetY, 1 - 2 * offsetX, 1 - 2 * offsetY, 'input', 'c');
	input.dom.type = 'text';
	input.dom.value = 'SmoothStop(x, 2)';
}

'static'; function fs(app, canvas) {
	var header = canvas.add(0, 0, 1, 0.25);
	fq(header, 'Function visualisation:');
	
	var displaywrap = canvas.add(0, 0.25, 1, 0.75);
	
	var offsetX = 20 / displaywrap.width;
	var offsetY = 20 / displaywrap.height;
	var display = displaywrap.add(offsetX, offsetY, 1 - 2 * offsetX, 1 - 2 * offsetY, 'canvas', 'd');
}

'static'; function ft(app, canvas) {
	var header = canvas.add(0, 0, 1, 0.25);
	fq(header, 'Animation visualisation:');
	
	var displaywrap = canvas.add(0, 0.25, 1, 0.75);
	
	var offsetX = 20 / displaywrap.width;
	var offsetY = 20 / displaywrap.height;
	var display = displaywrap.add(offsetX, offsetY, 1 - 2 * offsetX, 1 - 2 * offsetY, 'canvas', 'e');
}

// --------- Third level

'static'; function fu(app) {
	var context = app.context;
	fm(app);
	context.foo = fb('c').value;
	
	var points = new Array(vd);
	var x; // used by easingFunction
	for(var i = 0; i < vd; i++) {
		x = i / vd;
		points[i] = eval(context.foo);
	}
	
	// Draw points into canvas
	var canvas = fb('d');
	var ctx = canvas.getContext('2d');
	ctx.strokeStyle='#FFFFFF';
	
	ctx.clearRect(0, 0, canvas.width, canvas.height);
	ctx.beginPath();
	for(var i = 0; i < points.length - 1; i++) {
		ctx.moveTo(i * canvas.width / points.length, canvas.height - points[i] * canvas.height);
		ctx.lineTo((i + 1) * canvas.width / points.length, canvas.height - points[i + 1] * canvas.height);
		ctx.stroke();
	}
	ctx.closePath();
	
	// Setup animation
	context.time = 0;
	context.handle = setInterval(function() {
		fv(app);
	}, ve);
}

'static'; function fv(app) {
	var context = app.context;
	var canvas = fb('e');
	var ctx = canvas.getContext('2d');
	ctx.strokeStyle='#FFFFFF';
	
	var x = context.time /(1000 / ve * vf);
	var position = eval(context.foo) * canvas.width;
	
	ctx.clearRect(0, 0, canvas.width, canvas.height);
	ctx.beginPath();
	
	ctx.arc(position, canvas.height / 2, canvas.height / 4, 0, 2 * Math.PI);
	ctx.stroke();
	
	ctx.closePath();
	
	context.time++;
	if(context.time ==(1000 / ve * vf)) context.time = 0;
};// *** CORE LAYOUT VALUES ***
'static'; var vg = 0.0807;
'static'; var vh = vg;

/**
 *  @brief Return longest of two strings
 *  
 *  @param [in] str1 First string
 *  @param [in] str2 Second string
 *  @return Longer of both strings
 */
'static'; function fw(str1, str2) {
	if(str1.length > str2.length) return str1;
	return str2;
}

/**
 *  @brief Create button for templater
 *  
 *  @param [in] label Label written on the button
 *  @param [in] action Function callback of the button
 *  @param [in] id Optional id assigned to the button
 */
'static'; function fx(label, action, id) {
	this.label = label;
	this.action = action;
	this.id = ff(id, null);
}

/**
 *  @brief Render array of buttons in parent canvas
 *  
 *  @param [in] canvas Destination canvas to render
 *  @param [in] buttons Array of ButtonTemplates
 *  @param [in] x X coordinate within canvas
 *  @param [in] y Y coordinate within canvas
 *  @param [in] w Width of button array within canvas
 *  @param [in] h Height of button array within canvas
 *  @param [in] cacheID ID to cache with fontsizes
 *  
 *  @details If any of the fields of \p buttons is null, that
 *  element will be skipped and blank space will be rendered instead.
 */
'static'; function fy(canvas, buttons, x, y, w, h, cacheID) {
	var BUTTON_WIDTH = w / buttons.length;

	if(vc[cacheID] == null) {
		var longestStr = '';
		for(var i = 0; i < buttons.length; i++) {
			longestStr = fw(longestStr, buttons[i].label);
		}

		vc[cacheID] = fg(
			longestStr,
			canvas.width * BUTTON_WIDTH,
			canvas.height * h
		);
	}

	for(var i = 0; i < buttons.length; i++) {
		if(buttons[i] == null) continue;
		(function(p) {
			var opt = canvas.add(x + i * BUTTON_WIDTH, y, BUTTON_WIDTH, h, 'button', buttons[p].id);
			opt.pd('click', buttons[p].action);
			opt.pb(buttons[p].label, false, vc[cacheID]);
			if(i > 0) opt.pc('button_separator');
		}(i));
	}
}

/**
 *  @brief Render app standard toolbar
 *  
 *  @param [in] parentCanvas Parent canvas that should contain toolbar
 *  @param [in] buttons Array of ButtonTemplates
 *  @param [in] cacheID ID for fontsize cache
 *  
 *  @details This function will create new container element positioned appropriately within parent canvas,
 *  set its style and background color and then pe buttons with \ref fy.
 *  
 *  Use this in conjunction with \ref fA and \ref fB.
 */
'static'; function fz(parentCanvas, buttons, cacheID) {
	var canvas = parentCanvas.add(0, 1 - vh, 1, vh);
	canvas.pc('toolbar');
	
	fy(canvas, buttons, 0, 0, 1, 1, cacheID);
}

/**
 *  @brief Render header of the view
 *  
 *  @param [in] canvas Parent canvas where header should be rendered
 *  @param [in] label Label of the header
 *  
 *  @details This creates new container within canvas, sets the text label, sets background color.
 *  Container will be positioned appropriately within parent canvas. All headers use the same cache ID.
 *  
 *  Use this in conjunction with \ref fz and \ref fB.
 */
'static'; function fA(canvas, label) {
	var header = canvas.add(0, 0, 1, vg);
	
	var cacheID = 'f';
	if(vc[cacheID] == null) {
		vc[cacheID] = fg(label, header.width, header.height);
	}
	
	header.pb(label, false, vc[cacheID]);
	header.pc('header');
}

/**
 *  @brief Get canvas for drawing view context(header and toolbar free)
 *  
 *  @param [in] core Core canvas where drawing canvas will be embedded
 *  @param [in] hasHeader Whether header is present in view
 *  @return Resulting canvas
 *  
 *  @details Use this in conjunction with \ref fz and \ref fA.
 */
'static'; function fB(core, hasHeader) {
	var HEADER_OFFSET = ff(hasHeader, true) ? vg : 0;
	var result = core.add(0, HEADER_OFFSET, 1, 1 - HEADER_OFFSET - vh);
	result.pc('content');
	return result;
};